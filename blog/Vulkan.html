<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>RyanBeckett</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="../images/favicon.png">
    <link rel="preload" href="../images/seamless_paper_texture.png" as="image" />
    <link rel="stylesheet" href="../styles/global.css">
    <link rel="stylesheet" href="../styles/blogs.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
</head>

<body>
    <div class="blogWrapper">
        <h2>Creating a graphics renderer with Vulkan</h2>
        <a href="../index.html" class="homeBtn">Home</a>
        <!-- Chapter 1 -->
        <h4>How does Vulkan work?</h4>
        <p>
            Vulkan is a Graphics API at a much lower level to the hardware than OpenGL, 
            but also meaning more control over all of the inner workings which go into displaying graphics on our monitors.
        </p>
        <p>
            To fully understand how Vulkan is set up, it's important to understand how the graphics pipeline works.
            It can be quite daunting when we see all the steps necessary, but I plan to explain each of these
            and how they are handled by Vulkan so that you'll understand as a complete beginner!
        </p>

        <!-- Chapter 2 -->
        <h4>Graphics Pipeline</h4>
        <ol>
            <li><b>Input assembler:</b> Takes all of the raw vertex data</li>
            <li><b>Vertex shader:</b> Runs on every vertex & puts the model into screen space</li>
            <li><b>Tessellation shader:</b> Subdivides geometry, like making flat brick walls look more 3D</li>
            <li><b>Geometry shader:</b> A more flexible version of tessellation, although used less due to performance</li>
            <li><b>Rasterization:</b> Fragments<span class="refAsterisk">*</span> primitives (a line, point or triangle) & discards any that aren't displayed on screen or behind non-transparent objects</li>
            <li><b>Fragment shader:</b> Determines the framebuffers<span class="refAsterisk">**</span> colour & depth values for every fragment</li>
            <li><b>Color blending:</b> Pixels may blend to new colour if behind a transparent object such as a window or water, otherwise it may simply override it</li>
        </ol>
        <small><i><b>*</b> Fragment: Refers to the data necessary to generate a pixel in the framebuffer, eg: raster position, depth etc</i></small> <br />
        <small><i><b>**</b> Framebuffer: An array of information containing how each pixel should be rendered held in memory</i> </small><br/>
        
        <!-- Chapter 3 -->
        <h4>First steps in Vulkan</h4>
        <p>
            Vulkan requires us to do a lot of setting up to begin with, so rather than share all the code with you at this point,
            I'm going to abstract the steps needed into an ordered list so you understand what's required.
        </p>
        <ol>
            <li><b>Window:</b> The window which will contain our application</li>
            <li><b>Instance:</b> An instance of Vulkan, connecting our application and the Vulkan library</li>
            <li><b>Surface:</b> To present rendered images to (Vulkan is platform agnost so we can't present straight to the window)</li>
        </ol>

        <!-- Chapter 4 -->
        <h4>To be continued...</h4>
    </div>
</body>
</html>