<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>RyanBeckett</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="../images/favicon.png">
    <link rel="preload" href="../images/seamless_paper_texture.png" as="image" />
    <link rel="stylesheet" href="../styles/global.css">
    <link rel="stylesheet" href="../styles/blogs.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
</head>

<body>
    <div class="blogWrapper">
        <h2>Next steps in Vulkan</h2>
        <a href="../index.html" class="homeBtn">Home</a>

        <!-- Chapter 1 -->
        <h4>What's next?</h4>
        <p>
            Previously, we went over the stages using Vulkan from creating a window to displaying an image on the screen.
            This was a high level overview and a few details in between were missed out purposefully. Now I'd like to fill
            in those gaps and dig deeper into the process, particularly around the graphics pipeline, framebuffers & the swap chain.
        </p>


        <!-- Chapter 2 -->
        <h4>Vertex Buffers</h4>
        <p>
            These are instructions to tell our graphics pipeline how to build models and apply properties like colour.
            A simple vertex buffer where we only want to pass vertex positions and colours may look like this: 
        </p>
        <p>
            <code>layout(location = 0) in vec2 position;
                layout(location = 1) in vec3 color;
            </code><br /><br />
            <b>Output:</b><br />
            {
                <span class="vbPos">(a, b)</span>, 
                <span class="vbCol">(c, d, e)</span>, 
                <span class="vbPos">(f, g)</span>, 
                <span class="vbCol">(h, i, j)</span>,
                <span class="vbPos">(k, l)</span>, 
                <span class="vbCol">(m, n, o)</span>
            } 
            <br />Goes into the graphics pipeline
            <br />
            <span class="vbPos">position attribute is blue (x, y)</span>, <span class="vbCol">colour attribute is green (r, g, b)</span><br /><br />
        </p>
        <p>
            In the above example we are only using 1 binding and interleaving position and colour. It is possible to separate each attributes
            into it's own unique bindings which can yield better performance, however differences can be very small and it's recommended to
            stick with interleaved when dealing with simpler pipelines & algorithms.
        </p>
        <p>    
            Even if we separate our attributes into their own bindings, all bindings still go into the graphics pipeline on the same Vertex Buffer. 
            To visualize this, see below:
        </p>
        <p>
            <code>layout(location = 0) in vec2 position;
                layout(location = 1) in vec3 color;
                layout(location = 2) in vec3 normal;
            </code><br /><br />
            <b>Output:</b><br />
            [ { 
                <span class="vbPos">(a, b)</span>, 
                <span class="vbPos">(c, d)</span>, 
                <span class="vbPos">(e, f)</span>
            },
            { 
                <span class="vbCol">(g, h, i)</span>, 
                <span class="vbCol">(j, k, l)</span>, 
                <span class="vbCol">(m, n, p)</span>
            },
            {
                <span class="vbNorm">(p, q, r)</span>, 
                <span class="vbNorm">(s, t, u)</span>,
                <span class="vbNorm">(v, w, x)</span>
            } ]
            <br />Goes into the graphics pipeline as 1 vertex buffer
            <br />
            <span class="vbNorm">normal attribute is red (x, y, z)</span><br />
        </p>
    </div>
</body>
</html>